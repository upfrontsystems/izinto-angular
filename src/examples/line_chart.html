<!-- example of d3 line chart displaying query results -->
<html>

<!-- Google Fonts -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic">

<style>
</style>

<body>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- <script type='text/javascript' src='../assets/js/time-series-chart.js'></script> -->

    <div id="chart"></div>

    <script type="module">

        function timeSeriesChart() {
            var margin = { top: 20, right: 20, bottom: 20, left: 20 },
                width = 760,
                height = 120,
                xValue = function (d) { return d[0]; },
                yValue = function (d) { return d[1]; },
                xScale = d3.scaleTime(),
                yScale = d3.scaleLinear(),
                xAxis = d3.axisBottom(xScale).tickSize(6, 0),
                area = d3.area().x(X).y1(Y),
                line = d3.line().x(X).y(Y);

            function chart(selection) {
                selection.each(function (dataSet) {

                    // Convert data to standard representation greedily;
                    // this is needed for nondeterministic accessors.
                    dataSet = dataSet.map(function (data) {
                        return data.map(function (d, i) {
                            return [xValue.call(data, d, i), yValue.call(data, d, i)];
                        });
                    });

                    // Update the x-scale.
                    xScale
                        .domain(d3.extent(dataSet[0], function (d) { return d[0]; }))
                        .range([0, width - margin.left - margin.right]);

                    // Update the y-scale.
                    yScale
                        .domain([0, d3.max(dataSet[0], function (d) { return d[1]; })])
                        .range([height - margin.top - margin.bottom, 0]);

                    var create = svg.empty(),
                        trans = 1000;
                    if (create) {
                        var svg = d3.select(this)
                            .append('svg')
                            .attr('viewBox', '0 0 ' + width + ' ' + height)
                            .attr('preserveAspectRatio', 'xMidYMid meet')
                            .attr('width', width)
                            .attr('height', height)
                            .append('g')
                            .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');
                        svg.append('g').attr('class', 'grid');
                    } else {
                        d3.select(this)
                            .attr('viewBox', '0 0 ' + width + ' ' + height)
                            .attr('width', width)
                            .attr('height', height);
                    }

                    dataSet.forEach((data, index) => {
                        const ch = svg.select('g.line-chart-' + index);
                        if (ch.empty()) {
                            const linechart = svg.append('g').attr('class', 'line-chart-' + index);
                            linechart.append('path')
                                .datum(data)
                                .attr('fill', 'none')
                                .style('stroke', 'black')
                                .style('stroke-width', '2px')
                                .attr('class', 'line')
                                .attr('d', line);
                        } else {
                            ch.select('path').transition(trans).attr('d', line(dataset));
                        }
                    });
                    svg.append('g')
                        .attr('class', 'x-axis')
                        .attr('transform', "translate(0," + yScale.range()[0] + ")")
                        .call(xAxis);

                    addLegend(svg, dataSet);
                });
            }

            function addLegend(svg, dataSet) {
                svg.selectAll('g.legend').remove();
                var legendGroup = svg.append('g')
                    .attr('class', 'legend'),
                    chart = this,
                    labels = [],
                    yOffset = height - 60,
                    xOffset = -10;

                for (var dix = 0; dix < dataSet.length; dix += 1) {
                    var data = dataSet[dix];
                    if (dataset.length === 0) {
                        continue;
                    }
                    const header = data[0].header,
                        fieldName = dataSet.length === 1 ? data[0].fieldName : header;
                    const padding = 5,
                        rectWidth = charWidth,
                        recordValueWidth = 100,
                        labelWidth = fieldName.length * charWidth,
                        legendWidth = rectWidth + labelWidth + recordValueWidth;
                    const seriesLegend = legendGroup.append('g')
                        .style('font-size', '12px')
                        .attr('class', 'series-legend')
                        .attr('series-index', dix);
                    let textFill = 'black',
                        rectFill = 'black';
                    seriesLegend.append('rect')
                        .attr('x', xOffset)
                        .attr('y', yOffset - 5)
                        .attr('width', 10)
                        .attr('height', '2')
                        .attr('fill', rectFill);
                    const label = seriesLegend.append('text')
                        .style('font-weight', '400')
                        .attr('class', 'legend-label dataset-' + dix)
                        .attr('x', xOffset + rectWidth + padding)
                        .attr('y', yOffset)
                        .attr('fill', textFill)
                        .text(fieldName + ': ');
                    xOffset += legendWidth;
                }
            }

            // The x-accessor for the path generator; xScale ∘ xValue.
            function X(d) {
                return xScale(d[0]);
            }

            // The x-accessor for the path generator; yScale ∘ yValue.
            function Y(d) {
                return yScale(d[1]);
            }

            chart.margin = function (_) {
                if (!arguments.length) return margin;
                margin = _;
                return chart;
            };

            chart.width = function (_) {
                if (!arguments.lengtsh) return width;
                width = _;
                return chart;
            };

            chart.height = function (_) {
                if (!arguments.length) return height;
                height = _;
                return chart;
            };

            chart.x = function (_) {
                if (!arguments.length) return xValue;
                xValue = _;
                return chart;
            };

            chart.y = function (_) {
                if (!arguments.length) return yValue;
                yValue = _;
                return chart;
            };

            return chart;
        }

        var dateSelection = {};

        var chart = timeSeriesChart()
            .x(function (d) { return new Date(d[0]); })
            .y(function (d) { return +d[1]; });

        // load query result
        function loadQuery() {
            if (!dateSelection) {
                return;
            }
            var query = {
                'query':
                {
                    'name': 'table_query',
                    'values': { dev_id: '1406300003', range: dateSelection.dateRange, query_group_by: '1d' }
                }
            };

            // execute query
            window.top.postMessage(query, '*');
        }

        // build d3 table with results
        function buildTable(response) {
            if (!response['results']) {
                return;
            }

            // get single series result nested in database response
            var seriesList = response['results'][0].series;
            var dataSet = seriesList.map(function (series) { return series.values });

            d3.select("#chart")
                .datum(dataSet)
                .call(chart);
        }

        window.addEventListener("message", receiveMessage, false);

        function receiveMessage(event) {
            // date selection updated load query
            if (event.data.type === 'date_range_updated') {
                dateSelection = event.data.message;
                loadQuery();
                // set dashboard variables
            } else if (event.data.type === 'result') {
                buildTable(event.data.message.result.results);
            }
        }

        // send ready message
        window.top.postMessage({ 'status': 'ready' }, '*');

    </script>
</body>

</html>