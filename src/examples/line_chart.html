<!-- example of d3 line chart displaying query results -->
<html>

<!-- Google Fonts -->
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Roboto:300,300italic,700,700italic">

<style>
</style>

<body>

    <script src="https://d3js.org/d3.v6.min.js"></script>
    <!-- <script type='text/javascript' src='../assets/js/time-series-chart.js'></script> -->

    <div id="chart"></div>

    <script type="module">

        function timeSeriesChart() {
            var margin = { top: 20, right: 20, bottom: 20, left: 20 },
                width = 760,
                height = 120,
                xValue = function (d) { return d[0]; },
                yValue = function (d) { return d[1]; },
                xScale = d3.scaleTime(),
                yScale = d3.scaleLinear(),
                xAxis = d3.axisBottom(xScale).tickSize(6, 0),
                area = d3.area().x(X).y1(Y),
                line = d3.line().x(X).y(Y);

            function chart(selection) {
                selection.each(function (dataSet) {

                    // Convert data to standard representation greedily;
                    // this is needed for nondeterministic accessors.
                    dataSet = dataSet.map(function(data) {
                        return data.map(function (d, i) {
                            return [xValue.call(data, d, i), yValue.call(data, d, i)];
                        });
                    });

                    // Update the x-scale.
                    xScale
                        .domain(d3.extent(dataSet[0], function (d) { return d[0]; }))
                        .range([0, width - margin.left - margin.right]);

                    // Update the y-scale.
                    yScale
                        .domain([0, d3.max(dataSet[0], function (d) { return d[1]; })])
                        .range([height - margin.top - margin.bottom, 0]);

                    var svg = d3.select(this)
                        .append('svg')
                        .attr('viewBox', '0 0 ' + width + ' ' + height)
                        .attr('preserveAspectRatio', 'xMidYMid meet')
                        .attr('width', width)
                        .attr('height', height)
                        .append('g')
                        .attr('transform', 'translate(' + margin.left + ',' + margin.top + ')');

                    svg.append('g').attr('class', 'grid');

                    dataSet.forEach((data, index) => {
                        const ch = svg.select('g.line-chart-' + index);
                        if (ch.empty()) {
                            const linechart = svg.append('g').attr('class', 'line-chart-' + index);
                            linechart.append('path')
                                .datum(data)
                                .attr('fill', 'none')
                                .style('stroke', 'black')
                                .style('stroke-width', '2px')
                                .attr('class', 'line')
                                .attr('d', line);
                        } else {
                            ch.select('path').transition(trans).attr('d', line(dataset));
                        }
                    });
                    svg.append('g')
                        .attr('class', 'x-axis')
                        .attr('transform', "translate(0," + yScale.range()[0] + ")")
                        .call(xAxis);
                });
            }

            // The x-accessor for the path generator; xScale ∘ xValue.
            function X(d) {
                return xScale(d[0]);
            }

            // The x-accessor for the path generator; yScale ∘ yValue.
            function Y(d) {
                return yScale(d[1]);
            }

            chart.margin = function (_) {
                if (!arguments.length) return margin;
                margin = _;
                return chart;
            };

            chart.width = function (_) {
                if (!arguments.lengtsh) return width;
                width = _;
                return chart;
            };

            chart.height = function (_) {
                if (!arguments.length) return height;
                height = _;
                return chart;
            };

            chart.x = function (_) {
                if (!arguments.length) return xValue;
                xValue = _;
                return chart;
            };

            chart.y = function (_) {
                if (!arguments.length) return yValue;
                yValue = _;
                return chart;
            };

            return chart;
        }

        var dateSelection = {};

        var chart = timeSeriesChart()
            .x(function (d) {return new Date(d[0]);})
            .y(function (d) { return +d[1]; });

        // load query result
        function loadQuery() {
            if (!dateSelection) {
                return;
            }
            var query = {
                'query':
                {
                    'name': 'table_query',
                    'values': { dev_id: '1406300003', range: dateSelection.dateRange, query_group_by: '1d' }
                }
            };

            // execute query
            window.top.postMessage(query, '*');
        }

        // build d3 table with results
        function buildTable(response) {
            if (!response['results']) {
                return;
            }

            // get single series result nested in database response
            var seriesList = response['results'][0].series;
            var dataSet = seriesList.map(function(series) {return series.values});

            d3.select("#chart")
                .datum(dataSet)
                .call(chart);
        }

        window.addEventListener("message", receiveMessage, false);

        function receiveMessage(event) {
            // date selection updated load query
            if (event.data.type === 'date_range_updated') {
                dateSelection = event.data.message;
                loadQuery();
                // set dashboard variables
            } else if (event.data.type === 'result') {
                buildTable(event.data.message.result.results);
            }
        }

        // send ready message
        window.top.postMessage({ 'status': 'ready' }, '*');

    </script>
</body>

</html>